# 디자인패턴
## 디자인패턴이란?
과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식을 설명해 준다.
효율적인 코드를 만들기 위한 방법론

### 장점
- 개발자 간의 원활한 의사소통
- 소프트웨어 구조 파악에 용이
- 재사용을 통한 개발시간 단축

### 단점
- 객체지향 설계/구현 위주 사용
- 초기 투자 비용의 부담

## SOLID 원칙
- SRP: Single Responsibility Principle. 단일 책임 원칙.
- OCP: Open-Closed Principle. 개방-폐쇄 원칙
- LSP: Liskov Substitution Principle. 리스코프 치환 원칙.
- ISP: Interface Segregation Principle. 인터페이스 분리 원칙.
- DIP: Dependency Inversion Principle. 의존성 역전 원칙.

### 단일 책임 원칙 (Single Responsibility Principle)
- 하나의 객체는 반드시 하나의 동작만을 책임진다
- 객체가 담당하는 동작, 즉 책임이 많아질수록 해당 객체의 변경에 따른 영향도가 커지기 때문에 특정 객체의 책임 의존성을 낮추기 위함이다

### 개방-폐쇄 원칙 (Open-Closed Principle)
- 객체의 확장은 개방적으로, 객체의 수정은 폐쇄적으로 대하는 원칙
- 각 객체의 모듈화와 정보은닉을 추구하며 이를 통해 객체 간의 의존성을 최소화하여 수정에 따른 영향도를 낮춘다

### 리스코프 치환 원칙 (Liskov Substitution Principle)
부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙
올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다

### 인터페이스 분리 원칙 (Interface Segregation Principle)
- 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야한다는 원칙
구현할 객체에게 무의미한 메소드의 구현을 방지하기 위해 반드시 필요한 메소드만을 상속/구현하도록 권고한다
만약 상속할 객체의 규모가 크다면 해당 객체의 메소드를 작은 인터페이스로 나누는 것이 좋다

### 의존성 역전 원칙 (Dependency Inversion)
- 객체는 저수준 모듈보다 고수준 모듈에 의존해야한다는 원칙
(고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적 개념/ 저수준 모듈: 구현된 객체)
- 객체는 객체보다 인터페이스에 의존해야하며 가급적 객체의 상속은 인터페이스를 통해 이루어져야한다

## 디자인패턴 분류
### 생성 패턴 (Creation Pattern)
   - 객체 생성에 관련된 패턴
   - 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공

  - 싱글톤 패턴
  - 팩토리 메소드 패턴


### 구조 패턴(Structural Patterns)
- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
(예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴)

  - 어댑터 패턴
  - 컴포지트 패턴

### 행위 패턴(Behavioral Patterns)
- 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
- 한 객체가 여러 객체로 작업을 분배하는 방법, 객체 사이의 결합도를 최소화하는 것에 중점을 두는 방식

  - 탬플릿 메소드 패턴
  - 옵저버 패턴
  - 스트레티지 패턴
